#      面向对象

[TOC]



## 初识面向对象

![image-20210818053336596](https://i.loli.net/2021/08/18/YyOutabze8KpUn3.png)

![image-20210818053438291](https://i.loli.net/2021/08/18/n1ysNwdUpl2IKRL.png)



## 方法回顾

![image-20210818053737080](https://i.loli.net/2021/08/18/gjDzqfnMuBmlopi.png)



## 对象的创建分析

### 创建

![image-20210818053911818](https://i.loli.net/2021/08/18/5oihHVGacR6erpO.png)

```java
package OOP;



//学生类
public class Student {
    //属性:字段
    String name;
    int age;
    
    //方法
     public void study(){

         System.out.println(this.name+"学生在学习");
     }

}
/*
public static void main(String[] args) {
        //类:抽象的 ,实例化
        //实例化后会返回一个自己的对象
        //Student对象就是Student类的具体实例
        Student student = new Student();

        student.name = "小红";
        student.age = 3;

        System.out.println(student.name);
        System.out.println(student.age);
    }
 */
```

### 构造器

```java
package OOP;
//java-->class
public class Person {
    //一个类即使什么都不写,它也会存在一个方法
    //构造器

    String name;
    int age;
    //1.使用new关键字,实际在调用构造器
    //2.用来初始化值
    public Person() {
    }

    //有参构造:一旦有了有参构造,无参必须显示定义
    public Person(String name) {
        this.name = name;
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
/*
public static void main(String[] args) {

        //new 实例化一个对象
        Person person = new Person("Yixin",20);
        System.out.println(person.name);

    }
    ===================================================
    构造器:
        1.和类名相同
        2.没有返回值
    作用:
        1.new 本质在调用构造方法    
        2.初识话对象值
    注意点:
        1.有参构造:一旦有了有参构造,无参必须显示定义   
 */
```

### 类与对象小结

```java
/*

1.类与对象
    类是一个模板:抽象.对象是一个具体实例
2.方法
    定义.调用
3.对应的引用
    引用类型: 基本类型(8)
    对象是通过引用来操作的: 栈--->堆
4.属性:字段field 成员变量
    默认初始化:
        数字 0 0.0
        char : u0000
        boolean : false
        引用: null
  修饰符 属性类型 属性名 = 属性值 ;
5.对象的创建和使用
    - 必须使用new关键字创造对象,构造器 Person Yixin = new Person();
    - 对象的属性 Yixin.name
    - 对象的方法 Yixin.sleep()
6.类
    静态的属性 属性
    动态的行为 方法
    
    */
```

## 面向对象的三个特征

### 封装

![image-20210818053941618](https://i.loli.net/2021/08/18/bt8Dq5XgYVcInxm.png)

```java
package OOP;
/*
    1.提高程序的安全性,保护数据
    2.隐藏代码的实现细节
    3.同一接口
    4.系统可维护增加
 */


//类 private :私有
public class Student {
  //  属性私有
    private String name;//名字
    private int id; //学号
    private char sex;//性别
    private int age; //年龄

    //提供一些可以操作的属性方法
    //提供一些 public 的 get set 方法

    //get 获得这些数据
    public String getName(){
        return this.name;
    }

    //set 给这个数据设置值
    public void setName(){
        this.name = name;
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public char getSex() {
        return sex;
    }

    public void setSex(char sex) {
        this.sex = sex;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age > 120 || age < 0){
            this.age = 3;
        }else {
            this.age = age;
        }
    }
    
    /*
    public static void main(String[] args) {

        Student s1 = new Student();
        s1.setAge(18);
        System.out.println(s1.getAge());
    }
    
     */
    
}
```

### 继承

![image-20210818054037556](https://i.loli.net/2021/08/18/mWQ13YiG4Rr2z7l.png)

```java
package OOP.demo1;


public class Person {
    public void say() {
        System.out.println("说话");
    }
}

/*
package OOP.demo1;

//扩展
public class Student extends Person {
}

//基础默认类 object   ctrl+H 继承结构图
public static void main(String[] args) {

        Student student = new Student();
        student.say();
    }
*/

```

#### super

```java
super注意点:
    1.super调用父类的构造方法,必须在构造方法的第一个
    2.super 必须在子类的方法或构造器中
    3.super和this不能同时调用构造方法
VS this:
    代表不同的对象:
        this:代表调用者本身
        super:代表父类的对象应用
    前提:
        this:没有继承也可由使用
        super:只能在继承条件下使用
    构造方法:
        this()本类的构造
        super()父类的构造
```

```java
package OOP.demo2;


public class Person {
    public Person() {
        System.out.println("Person无参构造执行");
    }

    protected String name = "Yixin";
    //私有的无法被继承
    public void print(){
        System.out.println("Person");
    }

}
```

```java
package OOP.demo2;

public class Student extends Person {

    public Student() {
        //隐藏代码: 调用了父类的构造器

        super();//调用父类构造器,必须在子类构造器的第一行
        System.out.println("Student无参构造执行");
    }

    private String name = "xiaoming";

    public void test(String name){
        System.out.println(name);
        System.out.println(this.name);
        System.out.println(super.name);
    }
    public void print(){
        System.out.println("Student");
    }

    public void test1(){
        print();
        this.print();
//        super.print();
    }
}
```



```java
package OOP;


import OOP.demo2.Student;
import OOP.demo3.Person;

class Application {
    public static void main(String[] args) {
        Student student = new Student();
//        student.test("意心");
//            student.test1();

    }
}
```

#### 方法重写

```java
package OOP.demo3;

public class Student extends Person {
    //重写 父类 方法
    @Override
    public void run() {
        System.out.println("son");
    }
    // 子类 独有方法
    public void eat(){
        System.out.println("eat");
    }
}
```

### 多态

![image-20210818054336334](https://i.loli.net/2021/08/18/dPRjYpelJZxUWA7.png)

```java
package OOP.demo3;

public class Person {
    public  void run(){
        System.out.println("run");
    }

}


/*
多态注意事项
    1.多态是方法,属性没有多态
    2.父类和子类有联系 联系转换异常 ClassCastException !
    3.存在的条件: 继承关系 方法要重写 父类的引用指向子类 Father f1 = new son ();
 */

/*
public static void main(String[] args) {
        //对象的实际类型是确定的
        //new Student Person
        //可以指向的引用类型不确定 : 父类的引用指向子类


        // Student子类型: 能调用的方法是自己的和继承父类的
        Student s1 = new Student();
        //Person 父类型: 可以指向子类,但不能调用子类独有的方法
        Person s2 = new Student();
        Object s3 = new Student();

//        s2.eat(); //不行 子类独有方法
        //子类重写了父类的方法
        s2.run();
        //对象能执行的方法: 主要看左边的类型,和右边关系不大
        s1.eat();


    }

 */
```

#### instanceof 类型判断

```java
package OOP.demo4;

public class Person {
    public  void run(){
        System.out.println("run");
    }
}


/*
instanceof 类型判断

public static void main(String[] args) {
        //Object > Person > Student
        //Object > Person > Teacher
        //Object > String
        //三条继承线路


        //System.out.println(x instanceof y);
        Object Object = new Student();
        System.out.println(Object instanceof Student);//true
        System.out.println(Object instanceof Person);//true
        System.out.println(Object instanceof Object);//true
        System.out.println(Object instanceof Teacher);//fales
        System.out.println(Object instanceof String);//fales
        System.out.println("================================================");
        Person Person = new Student();
        System.out.println(Person instanceof Student);//true
        System.out.println(Person instanceof Person);//true
        System.out.println(Person instanceof Object);//true
        System.out.println(Person instanceof Teacher);//fales
//        System.out.println(Person instanceof String);//编译报错

        Student student = new Student();
        System.out.println(student instanceof Student);//true
        System.out.println(student instanceof Person);//true
        System.out.println(student instanceof Object);//true
//        System.out.println(student instanceof Teacher);//编译报错
//        System.out.println(student instanceof String);//编译报错


    }


//类型强转

    public static void main(String[] args) {
        //子类转换父类 可能丢失自己本来的方法
        //类型之间转换: 父 子
        //高    -->    强转           //低
        Person s1 = new Student();
        //将s1 转换成Student类 就能 使用Student方法
        // 父 调用 子 需要强转

        ((Student)s1).go();

//        Student s11= (Student) s1;
//        s11.go();


        1.父类引用指向子类的对象
        2.把子类转换为父类,向上转型
        3.把父类转换为子类,向下转型.强转
        4.方便方法的调用.减少重复代码


     */
```

### static

```java
package OOP.demo5;

//static
public class Student {
    private static  int age; //静态变量
    private  double score; //非静态变量

    public void run(){
        System.out.println("run");

    }
    public static void go(){
        System.out.println("go");
    }

    public static void main(String[] args) {
        Student s1 = new Student();
        System.out.println(Student.age);
//        System.out.println(Student.score); //错误

        System.out.println(s1.score);
        System.out.println(s1.age);
        Student.go();


    }




}
```

```java
package OOP.demo5;

public class Person {
    //2
    {
        System.out.println("匿名代码块");
    }
    //1
    static {

        System.out.println("静态代码块");
    }
    //3
    public Person() {
        System.out.println("构造方法");
    }

    public static void main(String[] args) {
        Person person = new Person();
        System.out.println("================");
        Person person1 = new Person();
    }

}
```



## 抽象类和接口

#### 抽象类

![image-20210818055202789](https://i.loli.net/2021/08/18/hOjkCAYNi8vt2HG.png)

```java
package OOP.demo6;
/**
 * @author YixinWen
 */
//抽象类的所有方法都必须继承它的子类,都必须要实现它的方法
//abstract 抽象类 extends 单继承  (接口可以多继承)
public  abstract class Action {
    //abstract ,抽象方法,只有方法名字,没有方法的实现
    public abstract void doSomething();
}
//1.不能new这个抽象类,只能靠子类实现它
//2.抽象类中可以普通方法
//3.抽象方法必须在抽象类中
```

```java
package OOP.demo6;


//抽象类的所有方法都必须继承它的子类,都必须要实现它的方法
public class Test extends Action {
    @Override
    public void doSomething() {

    }
}
```

#### 接口

![image-20210818055226185](https://i.loli.net/2021/08/18/5TfIqAwWuCBvZUJ.png)

```java
作用:
    1.约束
    2.定义方法,让不同的人实现
    3.接口不能实例化,接口中没有构造方法
    4.可以实现多个接口
    5.必须重写接口方法 implements
    6.public abstract
    6.public static final
```



```java
package OOP.demo7;

public class UserServiceImpl implements UserService,TimeService{
    @Override
    public void add(String name) {

    }

    @Override
    public void delete(String name) {

    }

    @Override
    public void update(String name) {

    }

    @Override
    public void query(String name) {

    }

    @Override
    public void time() {

    }
}
```

```java
package OOP.demo7;

public interface UserService {
    void add(String name);
    void delete(String name);
    void update(String name);
    void query(String name);
}
```



## 内部类

![image-20210818055303483](https://i.loli.net/2021/08/18/d1rzKSawGfBZAxb.png)

```java
package OOP.demo8;

public class Outer {

    private int id = 10;
    public void out(){
        System.out.println("这是外部类");
    }
    //内部类
    public class Inner{
        public void in(){
            System.out.println("这是内部类");
        }
    }
    //获得外部类的私有属性
    public void getID(){
        System.out.println(id);
    }
}
//一个java类中可以有多个class类,但只能有一个public class
class A{
    public static void main(String[] args) {

    }
}
```

```java
package OOP.demo8;


class Application {
    public static void main(String[] args) {
        Outer outer = new Outer();
        //通过这个外部来实现内部类
        Outer.Inner inner = outer.new Inner();
        inner.in();//这是内部类

    }
}
```

```java
package OOP.demo8;

public class test {
    //局部内部类
    public void method(){
        class Inner{
            public void in(){

            }
        }
    }
}
```

```java
package OOP.demo8;

public class wen {
    public static void main(String[] args) {
        //匿名内部类
         new Apple().eat();
        User user = new User() {
            @Override
            public void hello() {

            }
        };

    }
static class Apple{
        public void eat(){
            System.out.println("1");
        }
}


    interface User{
        void hello();

    }
}
```
